syntax = "proto3";
package qgb;

import "gogoproto/gogo.proto";
import "google/api/annotations.proto";

option go_package = "github.com/celestiaorg/celestia-app/x/qgb/types";

// Msg defines the state transitions possible for QGB
service Msg {
  // ValsetConfirm allows the validators to submit their signatures over the validator set.
  rpc ValsetConfirm(MsgValsetConfirm) returns (MsgValsetConfirmResponse) {
    option (google.api.http).post = "/qgb/valset_confirm";
  }
  // DataCommitmentConfirm allows the validators to submit a confirmation for a data commitment.
  rpc DataCommitmentConfirm(MsgDataCommitmentConfirm) returns (MsgDataCommitmentConfirmResponse) {
    option (google.api.http).post = "/qgb/data_commitment_confirm";
  }
  // SetOrchestratorAddress allows to set the orchestrator address
  rpc SetOrchestratorAddress(MsgSetOrchestratorAddress) returns (MsgSetOrchestratorAddressResponse) {
    option (google.api.http).post = "/qgb/set_orchestrator_address";
  }
}

// MsgSetOrchestratorAddress
// this message allows validators to delegate their voting responsibilities
// to a given key. This key is then used as an optional authentication method
// for sigining oracle claims
message MsgSetOrchestratorAddress {
  // The validator field is a celesvaloper1... string (i.e. sdk.ValAddress)
  // that references a validator in the active set
  string validator    = 1;
  // The orchestrator field is a celes1... string  (i.e. sdk.AccAddress) that
  // references the key that is being delegated to
  string orchestrator = 2;
  // This is a hex encoded 0x Ethereum public key that will be used by this validator
  // on Ethereum
  string eth_address  = 3;
}

// MsgSetOrchestratorAddressResponse
message MsgSetOrchestratorAddressResponse {}

// MsgValsetConfirm
// this is the message sent by the validators when they wish to submit their
// signatures over the validator set at a given block height. A validator must
// first call MsgSetEthAddress to set their Ethereum address to be used for
// signing. Then someone (anyone) must make a ValsetRequest, the request is
// essentially a messaging mechanism to determine which block all validators
// should submit signatures over. Finally validators sign the validator set,
// powers, and Ethereum addresses of the entire validator set at the height of a
// ValsetRequest and submit that signature with this message.
//
// If a sufficient number of validators (66% of voting power) (A) have set
// Ethereum addresses and (B) submit ValsetConfirm messages with their
// signatures it is then possible for anyone to view these signatures in the
// chain store and submit them to Ethereum to update the validator set
// -------------
message MsgValsetConfirm {
  uint64 nonce        = 1;
  string orchestrator = 2;
  string eth_address  = 3;
  string signature    = 4;
}

// MsgValsetConfirmResponse describes the response returned after the submission
// of a MsgValsetConfirm.
message MsgValsetConfirmResponse {}

// MsgDataCommitmentConfirm describes a data commitment for a set of blocks.
message MsgDataCommitmentConfirm {}

// MsgValsetConfirmResponse describes the response returned after the submission
// of a MsgDataCommitmentConfirm.
message MsgDataCommitmentConfirmResponse {}
