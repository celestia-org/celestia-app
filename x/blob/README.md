# `x/blob`

## Abstract

The `x/blob` module enables users to pay for arbitrary data to be published to the Celestia blockchain. Users create a single `MsgWirePayForBlob` transaction that is composed of:

1. `Blob` (Binary Large OBject): the data they wish to publish
2. `NamespaceId`: the namespace they wish to publish to
3. `ShareCommitment`: a signature and a commitment over their data when encoded into shares

After the `MsgWirePayForBlob` transaction is submitted to the network, a block producer malleates their transaction into a `MsgPayForBlob` which doesn't include their data (a.k.a blob). Both components get included in the data square in different namespaces: the `MsgPayForBlob` gets included in the transaction namespace and the associated blob gets included in the namespace the user specified in the original `MsgWirePayForBlob`. Further reading: [Message Block Layout](https://github.com/celestiaorg/celestia-specs/blob/master/src/rationale/message_block_layout.md)

After a block has been created, the user can verify that their data was included in a block via a blob inclusion proof. A blob inclusion proof uses the `ShareCommitment` in the original `MsgWirePayForBlob` and subtree roots of the block's data square to prove to the user that the shares that compose their original data do in fact exist in a particular block.

## State

The blob module doesn't maintain it's own state.

When a `MsgPayForBlob` is processed, it consumes gas based on the blob size.

## Messages

- [`MsgWirePayForBlob`](https://github.com/celestiaorg/celestia-app/blob/8b9c4c9d13fe0ccb6ea936cc26dee3f52b6f6129/proto/blob/tx.proto#L17-L19) is a message that is created and signed by the user but it never ends up on-chain.
- [`MsgPayForBlob`](https://github.com/celestiaorg/celestia-app/blob/8b9c4c9d13fe0ccb6ea936cc26dee3f52b6f6129/proto/blob/tx.proto#L39-L44) is a "malleated" message that is created from metadata in the original `MsgWirePayForBlob`. `MsgPayForBlob` does end up on-chain.

## PrepareProposal

The malleation process occurs during the PrepareProposal step.

## Events

- [`NewPayForBlobEvent`](https://github.com/celestiaorg/celestia-app/pull/213/files#diff-1ce55bda42cf160deca2e5ea1f4382b65f3b689c7e00c88085d7ce219e77303dR17-R21) is emitted with the signer's address and size of the blob that is paid for.

## Parameters

Key | Type | Example
--- | --- | ---
MinSquareSize | uint32 | 1
MaxSquareSize | uint32 | 128

### Usage

```shell
celestia-app tx blob payForBlob <hex encoded namespace> <hex encoded data> [flags]
```

### Programmatic Usage

There are tools to programmatically create, sign, and broadcast `MsgWirePayForBlob`s

```go
// create the raw WirePayForBlob transaction
wpfbMsg, err := apptypes.NewWirePayForBlob(block.Header.NamespaceId, blob, 16, 32, 64, 128)
if err != nil {
    return err
}

// we need to create a signature for each `MsgPayForBlob`s that
// could be generated by the block producer
// to do this, we create a custom `KeyringSigner` to sign messages programmatically
// which uses the standard cosmos-sdk `Keyring` to sign each `MsgPayForBlob`
keyringSigner, err := NewKeyringSigner(keyring, "keyring account name", "chain-id-1")
if err != nil {
    return err
}

// query for account information necessary to sign a valid tx
err = keyringSigner.QueryAccount(ctx, grpcClientConn)
if err != nil {
    return err
}

// generate the signatures for each `MsgPayForBlob` using the `KeyringSigner`,
// then set the gas limit for the tx
gasLimOption := types.SetGasLimit(200000)
err = pfbMsg.SignShareCommitments(keyringSigner, gasLimOption)
if err != nil {
    return err
}

// Build and sign the final `WirePayForBlob` tx that now contains the signatures
// for potential `MsgPayForBlob`s
signedTx, err := keyringSigner.BuildSignedTx(
    gasLimOption(signer.NewTxBuilder()),
    wpfbMsg,
)
if err != nil {
    return err
}
```

<!-- markdownlint-enable MD010 -->

### How is the `MessageShareCommitment` generated?

1. Split the blob into shares of size `appconsts.ShareSize`
1. Determine the `msgMinSquareSize` (the minimum square size the blob can fit into). This is done by taking the number of shares from the previous step and rounding up to the next perfect square that is a power of two.
1. Arrange the shares into a Merkle mountain range where each tree in the mountain range has a maximum size of the `msgMinSquareSize`.
1. Take the roots of the trees in the Merkle mountain range and create a new Merkle tree.
1. The share commitment is the Merkle root of the Merkle tree from the previous step.
